
"""
    IndexedData

A struct to hold data for indexed dynamic models.

# Fields
- `Y0::Float64`: Initial output level.
- `C0::Float64`: Initial consumption level.
- `LS0::Float64`: Initial labor supply.
- `KS0::Float64`: Initial capital stock.
- `I0::Float64`: Initial investment level.
- `goods::Vector{Symbol}`: List of goods in the economy.
- `X::DenseAxisArray`: Initial production levels for each good.
- `LD::DenseAxisArray`: Initial labor demand for each good.
- `KD::DenseAxisArray`: Initial capital demand for each good.
- `G::Float64`: Growth rate of the economy.
- `R::Float64`: Interest rate.
- `D::Float64`: Depreciation rate of capital.
- `K0::Float64`: Steady-state capital stock.
- `rk0::Float64`: Steady-state return to capital.
- `pk0::Float64`: Steady-state price of capital.
- `time_periods::UnitRange{Int}`: Range of time periods for the model.
- `time_periods_horizon::UnitRange{Int}`: Extended range of time periods for capital pricing.
- `QREF::DenseAxisArray{Float64, 1, Tuple{UnitRange{Int}}}`: Reference quantity levels over time.
- `PREF::DenseAxisArray{Float64, 1, Tuple{UnitRange{Int}}}`: Reference price levels over time.
"""
struct IndexedData
    Y0::Float64
    C0::Float64
    LS0::Float64
    KS0::Float64
    I0::Float64

    goods::Vector{Symbol}
    X::DenseAxisArray
    LD::DenseAxisArray
    KD::DenseAxisArray

    G::Float64
    R::Float64
    D::Float64
    K0::Float64
    rk0::Float64
    
    pk0::Float64

    time_periods::UnitRange{Int}
    time_periods_horizon::UnitRange{Int}
    QREF::DenseAxisArray{Float64, 1, Tuple{UnitRange{Int}}}
    PREF::DenseAxisArray{Float64, 1, Tuple{UnitRange{Int}}}

end

"""
    IndexedData(;
        Y0 = 200,
        C0 = 180,
        LS0 = 150,
        KS0 = 50,
        I0 = 20,
        goods = [:A, :B],
        X = DenseAxisArray([120.0, 80.0], goods),
        LD = DenseAxisArray([100.0, 50.0], goods),
        KD = DenseAxisArray([20.0, 30.0], goods),
        G = 0.02,
        R = 0.05,
        D = 0.02,
        start_year = 2000,
        end_year = 2100,
    )

Create an `IndexedData` instance with specified parameters. 

This function distributes labor and capital demands via a least squares 
calibration routine.
"""
function IndexedData(;
        Y0 = 200,
        C0 = 180,
        LS0 = 150,
        KS0 = 50,
        I0 = 20,
        goods = [:A, :B],
        X = DenseAxisArray([120.0, 80.0], goods),
        LD = DenseAxisArray([100.0, 50.0], goods),
        KD = DenseAxisArray([20.0, 30.0], goods),
        G = 0.02,
        R = 0.05,
        D = 0.02,
        start_year = 2000,
        end_year = 2100,
    )


    time_periods = start_year:end_year
    time_periods_horizon = start_year:(end_year+1)
    K0 = I0/(G+D)
    rk0 = (R+D) #(R-R*D+D)/(1-R) 
    pk0 = 1+R # 1/(1-R)

    
    QREF = DenseAxisArray((1+G).^(eachindex(time_periods).-1), time_periods)
    PREF = DenseAxisArray((1 / (1+R)).^(eachindex(time_periods_horizon).-1), time_periods_horizon)
    #PREF = DenseAxisArray((1 -R).^(eachindex(time_periods_horizon).-1), time_periods_horizon)

    adjusted_KS0 = K0*rk0

    M = JuMP.Model(Ipopt.Optimizer)
    JuMP.@variables(M, begin
        VK[g=goods] >= 0 # Calibrated value of capital earnings
        VL[g=goods] >= 0 # Calibrated value of labor earnings
    end)

    JuMP.@objective(M, Min, sum(1/KD[g]*(VK[g] - KD[g])^2 for g∈goods))

    JuMP.@constraints(M, begin
        VABAL[g=goods], VK[g] + VL[g] == KD[g] + LD[g]
        VKBAL, sum(VK[g] for g∈goods) == adjusted_KS0
    end)

    JuMP.optimize!(M)

    adjusted_LD = JuMP.value.(VL)
    adjusted_KD = JuMP.value.(VK)


    return IndexedData(Y0, C0, LS0, adjusted_KS0, I0, goods, X, adjusted_LD, adjusted_KD, G, R, D, K0, rk0, pk0, time_periods, time_periods_horizon, QREF, PREF)
end


"""
    dynamic_index_model(data::IndexedData)

Creates an indexed scalar MPSGE model based on the provided `data`.

This model is created to handle incorporating output shifts as predicted by
forcasters. We will generalize to calibration by assuming growth across sectors
differs because of sector-specific factor productivity changes. This has three steps:

1. Calibrate the multi-sector balanced growth model
2. Find the sector specific ad valorem subsidy to factor demand that satisfies a 
    constraint on output to be equal to the forecasted projection and correct for the
    induced income effects
3. Use the value of the subsidy to calculate an output coefficient that scales productivity

To do this we introduce a few auxiliary variables:

- `SK[g,t]`: Ad valorem subsidy (or tax) on the capital input to each sector
- `ADJ_PKJ[g,t]`: Tracks lump-sum income effects generated by paying the subsidy

This model is solved in three steps:

1. Ensure model, as written, is calibrated 
2. Set the the new quantities `QREFJ[g,t]` to the forecasted values and solve. 
    This will adjust the `SK[g,t]` variables to hit the targets
3. Fix the `SK[g,t]` and `ADJ_PKJ[g,t]` variables and solve for the new equilibrium



"""
function dynamic_index_model(data::IndexedData)

    Y0 = data.Y0
    C0 = data.C0
    LS0 = data.LS0
    KS0 = data.KS0
    I0 = data.I0

    time_periods = data.time_periods
    time_periods_horizon = data.time_periods_horizon

    G = data.G
    D = data.D
    K0 = data.K0
    rk0 = data.rk0

    QREF = data.QREF
    r = data.R
    pk0 = data.pk0
    PREF = data.PREF

    goods = data.goods

    X0 = data.X
    LD = data.LD
    KD = data.KD


    DYN = MPSGEModel()

    @parameters(DYN, begin
        TAX[t=time_periods], 0
        QREFJ[g=goods, t=time_periods], QREF[t]
        PHI[g=goods, t=time_periods], 1
    end)

    @sectors(DYN, begin
        Y[t=time_periods], (start = QREF[t], description = "Macro Output (transitory utility)")
        X[g=goods, t=time_periods], (start = QREF[t], description = "Production")
        KJ[g=goods, t=time_periods], (start = QREF[t], description = "Capital Input with productivity adj")
        I[t=time_periods], (start = QREF[t], description = "Investment")
        K[t=time_periods], (start = QREF[t], description = "Capital")
        C[t=time_periods], (start = QREF[t], description = "Consumption Index")
    end)

    @commodities(DYN, begin
        PY[t=time_periods], (start = PREF[t], description = "Price index on output")
        PX[g=goods, t=time_periods], (start = PREF[t], description = "Price index on sector output")
        PKJ[g=goods, t=time_periods], (start = PREF[t], description = "Price index on capital with prod adj")
        PC[t=time_periods], (start = PREF[t], description = "Price index on consumption")
        RK[t=time_periods], (start = PREF[t], description = "Present value return to capital")
        PL[t=time_periods], (start = PREF[t], description = "Present value wage")
        PK[t=time_periods_horizon], (start = PREF[t]*pk0, description = "Price index on capital")
        #PKT -> PKT = PK[2101]
    end)

    @consumer(DYN, RA)

    @auxiliary(DYN, TCAP, start = I0*QREF[end] + K0*(1-D)*QREF[end])
    @auxiliary(DYN, SK[g=goods,t=time_periods], start = 0)
    @auxiliary(DYN, ADJ_PKJ[g=goods,t=time_periods], start = 0)

    @production(DYN, Y[t=time_periods], [t=0, s=1], begin
        @output(PY[t], Y0, t)
        @input(PX[g=goods, t], X0[g], s)
    end)


    @production(DYN, X[g=goods, t=time_periods], [t=0, s=1], begin
        @output(PX[g, t], X0[g], t)
        @input(PKJ[g, t], KD[g], s)
        @input(PL[t], LD[g], s)
    end)

    @production(DYN, KJ[g=goods, t=time_periods], [t=0,s=0], begin
        @output(PKJ[g, t], PHI[g,t]*KD[g], t, taxes = [Tax(RA, -SK[g,t])])
        @input(RK[t], KD[g], s)
    end)

    @production(DYN, I[t=time_periods], [t=0, s=0], begin
        @output(PK[t+1], I0, t)
        @input(PY[t], I0, s, taxes = [Tax(RA, TAX[t])])
    end)

    @production(DYN, K[t=time_periods], [t=0, s=0], begin
        @output(PK[t+1], K0*(1-D), t)
        @output(RK[t], KS0, t)
        @input(PK[t], K0, s)
    end)

    @production(DYN, C[t=time_periods], [t=0, s=0], begin
        @output(PC[t], C0, t)
        @input(PY[t], C0, s)
    end)

    @demand(DYN, RA, begin
        @final_demand(PC[t=time_periods], C0*QREF[t], reference_price = PREF[t])
        @endowment(PK[time_periods[begin]], K0)
        @endowment(PL[t=time_periods], sum(LD[g] for g in goods)*QREF[t])
        @endowment(PK[time_periods_horizon[end]], -TCAP)
        @endowment(PKJ[g=goods, t = time_periods], ADJ_PKJ[g,t])
    end)


    @aux_constraint(DYN, TCAP, 
        C[time_periods[end-1]]*I[time_periods[end]] - I[time_periods[end-1]]*C[time_periods[end]]
    )

    for g=goods, t=time_periods
        @aux_constraint(DYN, SK[g, t],
            X[g,t] - QREFJ[g,t]
        )

        @aux_constraint(DYN, ADJ_PKJ[g,t],
            ADJ_PKJ[g,t] - KD[g]*SK[g,t]*KJ[g,t]
        )
    end

    return DYN
end



"""
    indexed_model_report(model::MPSGEModel, data::IndexedData; value_name = :value)

Generates a DataFrame report for the indexed model, showing percentage deviations 
from the baseline for key variables over time.

The DataFrame will contain four columns: `:time`, `:variable`, `:value`, and `:model`.

The `:variable` column indicates the economic variable (e.g., `:invest`, 
`:cons`, `:capital`, `:output`), the `:value` column contains the percentage
deviation from the baseline, and the `:model` column is a constant indicating
the name of the model (as specified by `value_name`).

Values of each variable are calculated as:

    100 * (value(model[:VAR][t]) / QREF[t] - 1)

where `VAR` is the variable of interest and `QREF[t]` is the baseline value as 
defined in `data.QREF`.
"""
function indexed_model_report(model::MPSGEModel, data::IndexedData, new_quantities; value_name = :value)
    time_periods = data.time_periods
    QREF = data.QREF

    df = DataFrame(
        time = time_periods,
        invest = [100*(value(model[:I][t])/QREF[t] - 1) for t in time_periods],
        cons = [100* ( value(model[:C][t])/QREF[t] - 1) for t in time_periods],
        capital = [100*(value(model[:K][t])/QREF[t] - 1) for t in time_periods],
        output = [100*(value(model[:Y][t])/QREF[t] - 1) for t in time_periods]
    ) |>
    x -> stack(x, Not(:time), variable_name = :variable, value_name = :value) |>
    x -> transform(x,
        :variable => ByRow(y-> value_name) => :model
    )

    return df
end